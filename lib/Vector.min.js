class Vector{constructor(t=0,i=0){this.x=t,this.y=i}get magnitude(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2))}set magnitude(t){this.normalize().scale(t)}get direction(){return Math.atan2(this.y,this.x)}set direction(t){var i=this.magnitude;const r=Math.round(Math.sin(t)*i*1e4)/1e4,e=Math.round(Math.cos(t)*i*1e4)/1e4;this.x=r,this.y=e}set(t,i){return this.x=t,this.y=i,this}copy(t){return this.x=t.x,this.y=t.y,this}up(){return this.direction=Math.PI,this}down(){return this.direction=0,this}left(){return this.direction=-Math.PI/2,this}right(){return this.direction=Math.PI/2,this}add(t){return this.x+=t.x,this.y+=t.y,this}subtract(t){return this.x-=t.x,this.y-=t.y,this}scale(t){return this.x*=t,this.y*=t,this}divide(t){return 0===t?this:(this.x/=t,this.y/=t,this)}normalize(){const t=this.magnitude;return 0===t?this:(this.x/=t,this.y/=t,this)}limit(t){return this.magnitude<=t?this:this.normalize().scale(t)}zero(){return this.x=0,this.y=0,this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}flip(){return this.x=-this.x,this.y=-this.y,this}flipHorizontal(){return this.y=-this.y,this}flipVertical(){return this.x=-this.x,this}rotate(t){const i=Math.sin(t),r=Math.cos(t),e=Math.round(1e4*(this.x*r-this.y*i))/1e4,s=Math.round(1e4*(this.x*i+this.y*r))/1e4;return this.x=e,this.y=s,this}distanceTo(t){const i=this.x-t.x,r=this.y-t.y;return Math.sqrt(Math.pow(i,2)+Math.pow(r,2))}angleTo(t){return this.direction-t.direction}lerp(t,i=.2,r=.1){return Vector.distanceBetween(this,t)<=r?(this.copy(t),this):(i<0&&(i=0),i>1&&(i=1),this.x+=(t.x-this.x)*i,this.y+=(t.y-this.y)*i,this)}moveTowards(t,i=.2,r=.1){return this}static up(t){return t?Vector.copy(t).up():(new Vector).up()}static down(t){return t?Vector.copy(t).down():(new Vector).down()}static left(t){return t?Vector.copy(t).left():(new Vector).left()}static right(t){return t?Vector.copy(t).right():(new Vector).right()}static createUnitVector(t){const i=new Vector(0,1);return i.direction=t,i}static copy(t){return(new Vector).copy(t)}static add(t,i){return Vector.copy(t).add(i)}static subtract(t,i){return Vector.copy(t).subtract(i)}static scale(t,i){return Vector.copy(t).scale(i)}static divide(t,i){return Vector.copy(t).divide(i)}static normalize(t){return Vector.copy(t).normalize()}static limit(t,i){return Vector.copy(t).limit(i)}static round(t){return Vector.copy(t).round()}static floor(t){return Vector.copy(t).floor()}static ceil(t){return Vector.copy(t).ceil()}static rotate(t,i){return Vector.copy(t).rotate(i)}static flip(t){return Vector.copy(t).flip()}static flipHorizontal(t){return Vector.copy(t).flipHorizontal()}static flipVertical(t){return Vector.copy(t).flipVertical()}static lerp(t,i,r=.2,e=.1){return Vector.copy(t).lerp(i,r)}static moveTowards(t,i,r=.2,e=.1){return Vector.copy(t).moveTowards(i,r,e)}static isEqual(t,i){return t.x===i.x&&t.y===i.y}static distanceBetween(t,i){return t.distanceTo(i)}static angleBetween(t,i){return t.angleTo(i)}static dotProduct(t,i){return t.x*i.x+t.y*i.y}}export{Vector};